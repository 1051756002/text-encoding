(function(global){
  "use strict";

  //
  // Utilities
  //

  /**
   * @param {number} a
   * @param {number} min
   * @param {number} max
   */
  function inRange(a, min, max) {
    return min <= a && a <= max;
  }

  /** @param {Uint8Array} bytes */
  function ByteInputStream(bytes) {
    var pos = 0;
    return {
      get: function() {
        return (pos >= bytes.length) ? eof : bytes[pos];
      },
      offset: function (n) {
        pos += n;
        if (pos < 0) {
          throw new Error("Seeking past start of the buffer");
        }
        if (pos > bytes.length) {
          throw new Error("Seeking past EOF");
        }
      },
      match: function(test) {
        if (test.length > pos + bytes.length) {
          return false;
        }
        var i;
        for (i = 0; i < test.length; i += 1) {
          if (bytes[pos + i] !== test[i]) {
            return false;
          }
        }
        return true;
      }
    };
  }

  /** @param {Array.<number>} bytes */
  function ByteOutputStream(bytes) {
    var pos = 0;
    return {
      write: function(/*...*/) {
        for (var i = 0; i < arguments.length; ++i) {
          bytes[pos++] = arguments[i];
        }
      }
    };
  }

  /** @param {string} string */
  function CodePointInputStream(string) {
    var pos = 0, cps = (function () {
      var cps = [];
      // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
      var i = 0, n = string.length;
      while (i < string.length) {
        var c = string.charCodeAt(i);
        if (!inRange(c, 0xD800, 0xDFFF)) {
          i += 1;
          cps.push(c);
        } else if (inRange(c, 0xDC00, 0xDFFF)) {
          i += 1;
          cps.push(fallback_code_point);
        } else { // (inRange(cu, 0xD800, 0xDBFF))
          if (i === n - 1) {
            cps.push(fallback_code_point);
          }
          var d = string.charCodeAt(i + 1);
          if (inRange(d, 0xDC00, 0xDFFF)) {
            var a = c & 0x3FF;
            var b = d & 0x3FF;
            i += 2;
            cps.push(0x10000 + (a << 10) + b);
          } else {
            i += 1;
            cps.push(fallback_code_point);
          }
        }
      }
      return cps;
    }());

    return {
      eof: function () {
        return (pos >= cps.length);
      },
      offset: function (n) {
        pos += n;
        if (pos < 0) {
          throw new Error("Seeking past start of the buffer");
        }
        if (pos > cps.length) {
          throw new Error("Seeking past EOF");
        }
      },
      read: function () {
        if (pos >= cps.length) {
          return eof;
        }
        return cps[pos++];
      }
    };
  }

  function CodePointOutputStream() {
    var string = '';
    return {
      string: function () {
        return string;
      },
      emit: function(c) {
        if (c <= 0xFFFF) {
          string += String.fromCharCode(c);
        } else {
          c -= 0x10000;
          string += String.fromCharCode(0xD800 + ((c >> 10) & 0x3ff));
          string += String.fromCharCode(0xDC00 + (c & 0x3ff));
        }
      }
    };
  }

  //
  // Implementation of Encoding Standard
  //

  //
  // 3. Terminology
  //

  /** @const */ var fallback_code_point = 0xFFFD;

  //
  // 4. Encodings
  //

  // TODO: Distinguish EOF byte and EOF code point
  /** @const */ var eof = -1;


  /**
   * @param {boolean} fatal
   * @param {number=} opt_code_point
   * @return {number}
   */
  function decoderError(fatal, opt_code_point) {
    if (fatal) {
      throw new Error("EncodingError");
    }
    return opt_code_point || fallback_code_point;
  }

  /**
   * @param {number} code_point
   */
  function encoderError(code_point) {
    throw new Error("EncodingError");
  }

  /**
   * @param {string} label
   */
  function getEncoding(label) {
    label = String(label).trim().toLowerCase();
    var i;
    for (i = 0; i < codecs.length; ++i) {
      if (codecs[i].labels.indexOf(label) !== -1) {
        return codecs[i];
      }
    }
    throw new Error("Unknown encoding: " + label);
  }


  /** @type {Array.<{name:string,
   *                 labels:Array.<string>,
   *                 getEncoder:function({fatal:boolean}),
   *                 getDecoder:function({fatal:boolean})
   *               }>} */
  var codecs = [
    // The Encoding
    {
      name: 'utf-8',
      labels: ['utf-8'],
      getEncoder: function (options) { return new UTF8Encoder(options); },
      getDecoder: function (options) { return new UTF8Decoder(options); }
    },

    // Legacy single-byte encodings
    // From: http://dvcs.w3.org/hg/encoding/raw-file/tip/single-byte-encodings.json
    {
      "name":"ibm864",
      "labels":["cp864",
                "ibm864"]
    },
    {
      "name":"ibm866",
      "labels":["cp866",
                "ibm866"]
    },
    {
      "name":"iso-8859-2",
      "labels":["csisolatin2",
                "iso-8859-2",
                "iso-ir-101",
                "iso8859-2",
                "iso_8859-2",
                "l2",
                "latin2"]
    },
    {
      "name":"iso-8859-3",
      "labels":["csisolatin3",
                "iso-8859-3",
                "iso_8859-3",
                "iso-ir-109",
                "l3",
                "latin3"]
    },
    {
      "name":"iso-8859-4",
      "labels":["csisolatin4",
                "iso-8859-4",
                "iso_8859-4",
                "iso-ir-110",
                "l4",
                "latin4"]
    },
    {
      "name":"iso-8859-5",
      "labels":["csisolatincyrillic",
                "cyrillic",
                "iso-8859-5",
                "iso_8859-5",
                "iso-ir-144"]
    },
    {
      "name":"iso-8859-6",
      "labels":["arabic",
                "csisolatinarabic",
                "ecma-114",
                "iso-8859-6",
                "iso_8859-6",
                "iso-ir-127"]
    },
    {
      "name":"iso-8859-7",
      "labels":["csisolatingreek",
                "ecma-118",
                "elot_928",
                "greek",
                "greek8",
                "iso-8859-7",
                "iso_8859-7",
                "iso-ir-126"]
    },
    {
      "name":"iso-8859-8",
      "labels":["csisolatinhebrew",
                "hebrew",
                "iso-8859-8",
                "iso-8859-8-i",
                "iso-ir-138",
                "iso_8859-8",
                "visual"]
    },
    {
      "name":"iso-8859-10",
      "labels":["csisolatin6",
                "iso-8859-10",
                "iso-ir-157",
                "iso8859-10",
                "l6",
                "latin6"]
    },
    {
      "name":"iso-8859-13",
      "labels":["iso-8859-13"]
    },
    {
      "name":"iso-8859-14",
      "labels":["iso-8859-14",
                "iso8859-14"]
    },
    {
      "name":"iso-8859-15",
      "labels":["iso-8859-15",
                "iso_8859-15"]
    },
    {
      "name":"iso-8859-16",
      "labels":["iso-8859-16"]
    },
    {
      "name":"koi8-r",
      "labels":["koi8-r", "koi8_r"]
    },
    {
      "name":"koi8-u",
      "labels":["koi8-u"]
    },
    {
      "name":"macintosh",
      "labels":["csmacintosh",
                "mac",
                "macintosh",
                "x-mac-roman"]
    },
    {
      "name":"windows-874",
      "labels":["iso-8859-11",
                "tis-620",
                "windows-874"]
    },
    {
      "name":"windows-1250",
      "labels":["windows-1250",
                "x-cp1250"]
    },
    {
      "name":"windows-1251",
      "labels":["windows-1251",
                "x-cp1251"]
    },
    {
      "name":"windows-1252",
      "labels":["ascii",
                "ansi_x3.4-1968",
                "csisolatin1",
                "iso-8859-1",
                "iso8859-1",
                "iso_8859-1",
                "l1",
                "latin1",
                "us-ascii",
                "windows-1252"]
    },
    {
      "name":"windows-1253",
      "labels":["cp1253",
                "windows-1253"]
    },
    {
      "name":"windows-1254",
      "labels":["csisolatin5",
                "iso-8859-9",
                "iso-ir-148",
                "l5",
                "latin5",
                "windows-1254"]
    },
    {
      "name":"windows-1255",
      "labels":["cp1255",
                "windows-1255"]
    },
    {
      "name":"windows-1256",
      "labels":["cp1256",
                "windows-1256"]
    },
    {
      "name":"windows-1257",
      "labels":["windows-1257"]
    },
    {
      "name":"windows-1258",
      "labels":["cp1258",
                "windows-1258"]
    },
    {
      "name":"x-mac-cyrillic",
      "labels":["x-mac-cyrillic",
                "x-mac-ukrainian"]
    },

    // Legacy multi-byte Chinese (simplified) encodings
    {
      name: "gbk",
      labels: ["chinese",
               "csgb2312",
               "csiso58gb231280",
               "gb2312",
               "gb_2312",
               "gb_2312-80",
               "gbk",
               "iso-ir-58",
               "x-gbk"],
      getEncoder: function (options) { return new GBKEncoder(false, options); },
      getDecoder: function (options) { return new GBKDecoder(false, options); }
    },

    {
      name: "gb18030",
      labels: ["gb18030"],
      getEncoder: function (options) { return new GBKEncoder(true, options); },
      getDecoder: function (options) { return new GBKDecoder(true, options); }
    },

    {
      name: "hz-gb-2312",
      labels: ["hz-gb-2312"],
      getEncoder: function (options) { return new HZGB2312Encoder(options); },
      getDecoder: function (options) { return new HZGB2312Decoder(options); }
    },

    // Legacy multi-byte Chinese (traditional) encodings
    {
      name: "big5",
      labels: ["big5",
               "big5-hkscs",
               "cn-big5",
               "csbig5",
               "x-x-big5"],
      getDecoder: function (options) { return new Big5Decoder(options); }
    },

    // Legacy multi-byte Japanese encodings
    {
      name: 'euc-jp',
      labels: ["cseucjpkdfmtjapanese",
               "euc-jp",
               "x-euc-jp"],
      getDecoder: function (options) { return new EUCJPDecoder(options); }
    },

    {
      name: "iso-2022-jp",
      labels: ["csiso2022jp",
               "iso-2022-jp"],
      getDecoder: function (options) { return new ISO2022JPDecoder(options); }
    },

    {
      name: "shift_jis",
      labels: ["csshiftjis",
               "ms_kanji",
               "shift-jis",
               "shift_jis",
               "windows-31j",
               "x-sjis"],
      getDecoder: function (options) { return new ShiftJISDecoder(options); }
    },

    // Legacy multi-byte Korean encodings
    {
      name: "euc-kr",
      labels: ["csksc56011987",
               "csueckr",
               "euc-kr",
               "iso-ir-149",
               "korean",
               "ks_c_5601-1989",
               "ksc5601",
               "ksc_5601",
               "windows-949"],
      getDecoder: function (options) { return new EUCKRDecoder(options); }
    },

    {
      name: "iso-2022-kr",
      labels: ["csiso2022kr",
               "iso-2022-kr"],
      getEncoder: function (options) { return new ISO2022KREncoder(options); },
      getDecoder: function (options) { return new ISO2022KRDecoder(options); }
    },

    // Legacy utf-16 encodings
    {
      name: 'utf-16',
      labels: ['utf-16', 'utf-16le'],
      getEncoder: function (options) { return new UTF16Encoder(false, options); },
      getDecoder: function (options) { return new UTF16Decoder(false, options); }
    },

    {
      name: 'utf-16be',
      labels: ['utf-16be'],
      getEncoder: function (options) { return new UTF16Encoder(true, options); },
      getDecoder: function (options) { return new UTF16Decoder(true, options); }
    }
  ];

  var name_to_encoding = {};
  codecs.forEach(function(encoding) {
    name_to_encoding[encoding.name] = encoding;
  });

  //
  // 5. Indexes
  //

  /**
   * @param {number} code_point
   * @param {Array.<?number>} index
   */
  function pointerFor(code_point, index) {
    var pointer = index.indexOf(code_point);
    return pointer === -1 ? null : pointer;
  }

  /** @type {Object.<string, (Array.<number>|Array.<Array.<number>>)>} */
  var indexes = {
    "gb18030": [[0,128],[36,165],[38,169],[45,178],[50,184],[81,216],[89,226],[95,235],[96,238],[100,244],[103,248],[104,251],[105,253],[109,258],[126,276],[133,284],[148,300],[172,325],[175,329],[179,334],[208,364],[306,463],[307,465],[308,467],[309,469],[310,471],[311,473],[312,475],[313,477],[341,506],[428,594],[443,610],[544,712],[545,716],[558,730],[741,930],[742,938],[749,962],[750,970],[805,1026],[819,1104],[820,1106],[7922,8209],[7924,8215],[7925,8218],[7927,8222],[7934,8231],[7943,8241],[7944,8244],[7945,8246],[7950,8252],[8062,8365],[8148,8452],[8149,8454],[8152,8458],[8164,8471],[8174,8482],[8236,8556],[8240,8570],[8262,8596],[8264,8602],[8374,8713],[8380,8720],[8381,8722],[8384,8726],[8388,8731],[8390,8737],[8392,8740],[8393,8742],[8394,8748],[8396,8751],[8401,8760],[8406,8766],[8416,8777],[8419,8781],[8424,8787],[8437,8802],[8439,8808],[8445,8816],[8482,8854],[8485,8858],[8496,8870],[8521,8896],[8603,8979],[8936,9322],[8946,9372],[9046,9548],[9050,9588],[9063,9616],[9066,9622],[9076,9634],[9092,9652],[9100,9662],[9108,9672],[9111,9676],[9113,9680],[9131,9702],[9162,9735],[9164,9738],[9218,9793],[9219,9795],[11329,11906],[11331,11909],[11334,11913],[11336,11917],[11346,11928],[11361,11944],[11363,11947],[11366,11951],[11370,11956],[11372,11960],[11375,11964],[11389,11979],[11682,12284],[11686,12292],[11687,12312],[11692,12319],[11694,12330],[11714,12351],[11716,12436],[11723,12447],[11725,12535],[11730,12543],[11736,12586],[11982,12842],[11989,12850],[12102,12964],[12336,13200],[12348,13215],[12350,13218],[12384,13253],[12393,13263],[12395,13267],[12397,13270],[12510,13384],[12553,13428],[12851,13727],[12962,13839],[12973,13851],[13738,14617],[13823,14703],[13919,14801],[13933,14816],[14080,14964],[14298,15183],[14585,15471],[14698,15585],[15583,16471],[15847,16736],[16318,17208],[16434,17325],[16438,17330],[16481,17374],[16729,17623],[17102,17997],[17122,18018],[17315,18212],[17320,18218],[17402,18301],[17418,18318],[17859,18760],[17909,18811],[17911,18814],[17915,18820],[17916,18823],[17936,18844],[17939,18848],[17961,18872],[18664,19576],[18703,19620],[18814,19738],[18962,19887],[19043,40870],[33469,59244],[33470,59336],[33471,59367],[33484,59413],[33485,59417],[33490,59423],[33497,59431],[33501,59437],[33505,59443],[33513,59452],[33520,59460],[33536,59478],[33550,59493],[37845,63789],[37921,63866],[37948,63894],[38029,63976],[38038,63986],[38064,64016],[38065,64018],[38066,64021],[38069,64025],[38075,64034],[38076,64037],[38078,64042],[39108,65074],[39109,65093],[39113,65107],[39114,65112],[39115,65127],[39116,65132],[39265,65375],[39394,65510],[189000,65536]],
    "ibm864":[176,183,8729,8730,9618,9472,9474,9532,9508,9516,9500,9524,9488,9484,9492,9496,946,8734,966,177,189,188,8776,171,187,65271,65272,155,156,65275,65276,159,160,173,65154,163,164,65156,null,null,65166,65167,65173,65177,1548,65181,65185,65189,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,65233,1563,65201,65205,65209,1567,162,65152,65153,65155,65157,65226,65163,65165,65169,65171,65175,65179,65183,65187,65191,65193,65195,65197,65199,65203,65207,65211,65215,65217,65221,65227,65231,166,172,247,215,65225,1600,65235,65239,65243,65247,65251,65255,65259,65261,65263,65267,65213,65228,65230,65229,65249,65149,1617,65253,65257,65260,65264,65266,65232,65237,65269,65270,65245,65241,65265,9632,null],
    "ibm866":[1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,9617,9618,9619,9474,9508,9569,9570,9558,9557,9571,9553,9559,9565,9564,9563,9488,9492,9524,9516,9500,9472,9532,9566,9567,9562,9556,9577,9574,9568,9552,9580,9575,9576,9572,9573,9561,9560,9554,9555,9579,9578,9496,9484,9608,9604,9612,9616,9600,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1025,1105,1028,1108,1031,1111,1038,1118,176,8729,183,8730,8470,164,9632,160],
    "iso-8859-2":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,260,728,321,164,317,346,167,168,352,350,356,377,173,381,379,176,261,731,322,180,318,347,711,184,353,351,357,378,733,382,380,340,193,194,258,196,313,262,199,268,201,280,203,282,205,206,270,272,323,327,211,212,336,214,215,344,366,218,368,220,221,354,223,341,225,226,259,228,314,263,231,269,233,281,235,283,237,238,271,273,324,328,243,244,337,246,247,345,367,250,369,252,253,355,729],
    "iso-8859-3":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,294,728,163,164,null,292,167,168,304,350,286,308,173,null,379,176,295,178,179,180,181,293,183,184,305,351,287,309,189,null,380,192,193,194,null,196,266,264,199,200,201,202,203,204,205,206,207,null,209,210,211,212,288,214,215,284,217,218,219,220,364,348,223,224,225,226,null,228,267,265,231,232,233,234,235,236,237,238,239,null,241,242,243,244,289,246,247,285,249,250,251,252,365,349,729],
    "iso-8859-4":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,260,312,342,164,296,315,167,168,352,274,290,358,173,381,175,176,261,731,343,180,297,316,711,184,353,275,291,359,330,382,331,256,193,194,195,196,197,198,302,268,201,280,203,278,205,206,298,272,325,332,310,212,213,214,215,216,370,218,219,220,360,362,223,257,225,226,227,228,229,230,303,269,233,281,235,279,237,238,299,273,326,333,311,244,245,246,247,248,371,250,251,252,361,363,729],
    "iso-8859-5":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,173,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,8470,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,167,1118,1119],
    "iso-8859-6":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,null,null,null,164,null,null,null,null,null,null,null,1548,173,null,null,null,null,null,null,null,null,null,null,null,null,null,1563,null,null,null,1567,null,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,null,null,null,null,null,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,null,null,null,null,null,null,null,null,null,null,null,null,null],
    "iso-8859-7":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,8216,8217,163,8364,8367,166,167,168,169,890,171,172,173,null,8213,176,177,178,179,900,901,902,183,904,905,906,187,908,189,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,null,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,null],
    "iso-8859-8":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,null,162,163,164,165,166,167,168,169,215,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,247,187,188,189,190,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8215,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,null,null,8206,8207,null],
    "iso-8859-10":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,260,274,290,298,296,310,167,315,272,352,358,381,173,362,330,176,261,275,291,299,297,311,183,316,273,353,359,382,8213,363,331,256,193,194,195,196,197,198,302,268,201,280,203,278,205,206,207,208,325,332,211,212,213,214,360,216,370,218,219,220,221,222,223,257,225,226,227,228,229,230,303,269,233,281,235,279,237,238,239,240,326,333,243,244,245,246,361,248,371,250,251,252,253,254,312],
    "iso-8859-13":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,8221,162,163,164,8222,166,167,216,169,342,171,172,173,174,198,176,177,178,179,8220,181,182,183,248,185,343,187,188,189,190,230,260,302,256,262,196,197,280,274,268,201,377,278,290,310,298,315,352,323,325,211,332,213,214,215,370,321,346,362,220,379,381,223,261,303,257,263,228,229,281,275,269,233,378,279,291,311,299,316,353,324,326,243,333,245,246,247,371,322,347,363,252,380,382,8217],
    "iso-8859-14":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,7682,7683,163,266,267,7690,167,7808,169,7810,7691,7922,173,174,376,7710,7711,288,289,7744,7745,182,7766,7809,7767,7811,7776,7923,7812,7813,7777,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,372,209,210,211,212,213,214,7786,216,217,218,219,220,221,374,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,373,241,242,243,244,245,246,7787,248,249,250,251,252,253,375,255],
    "iso-8859-15":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,8364,165,352,167,353,169,170,171,172,173,174,175,176,177,178,179,381,181,182,183,382,185,186,187,338,339,376,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255],
    "iso-8859-16":[128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,260,261,321,8364,8222,352,167,353,169,536,171,377,173,378,379,176,177,268,322,381,8221,182,183,382,269,537,187,338,339,376,380,192,193,194,258,196,262,198,199,200,201,202,203,204,205,206,207,272,323,210,211,212,336,214,346,368,217,218,219,220,280,538,223,224,225,226,259,228,263,230,231,232,233,234,235,236,237,238,239,273,324,242,243,244,337,246,347,369,249,250,251,252,281,539,255],
    "koi8-r":[9472,9474,9484,9488,9492,9496,9500,9508,9516,9524,9532,9600,9604,9608,9612,9616,9617,9618,9619,8992,9632,8729,8730,8776,8804,8805,160,8993,176,178,183,247,9552,9553,9554,1105,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,9569,1025,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,169,1102,1072,1073,1094,1076,1077,1092,1075,1093,1080,1081,1082,1083,1084,1085,1086,1087,1103,1088,1089,1090,1091,1078,1074,1100,1099,1079,1096,1101,1097,1095,1098,1070,1040,1041,1062,1044,1045,1060,1043,1061,1048,1049,1050,1051,1052,1053,1054,1055,1071,1056,1057,1058,1059,1046,1042,1068,1067,1047,1064,1069,1065,1063,1066],
    "koi8-u":[9472,9474,9484,9488,9492,9496,9500,9508,9516,9524,9532,9600,9604,9608,9612,9616,9617,9618,9619,8992,9632,8729,8730,8776,8804,8805,160,8993,176,178,183,247,9552,9553,9554,1105,1108,9556,1110,1111,9559,9560,9561,9562,9563,1169,9565,9566,9567,9568,9569,1025,1028,9571,1030,1031,9574,9575,9576,9577,9578,1168,9580,169,1102,1072,1073,1094,1076,1077,1092,1075,1093,1080,1081,1082,1083,1084,1085,1086,1087,1103,1088,1089,1090,1091,1078,1074,1100,1099,1079,1096,1101,1097,1095,1098,1070,1040,1041,1062,1044,1045,1060,1043,1061,1048,1049,1050,1051,1052,1053,1054,1055,1071,1056,1057,1058,1059,1046,1042,1068,1067,1047,1064,1069,1065,1063,1066],
    "macintosh":[196,197,199,201,209,214,220,225,224,226,228,227,229,231,233,232,234,235,237,236,238,239,241,243,242,244,246,245,250,249,251,252,8224,176,162,163,167,8226,182,223,174,169,8482,180,168,8800,198,216,8734,177,8804,8805,165,181,8706,8721,8719,960,8747,170,186,937,230,248,191,161,172,8730,402,8776,8710,171,187,8230,160,192,195,213,338,339,8211,8212,8220,8221,8216,8217,247,9674,255,376,8260,8364,8249,8250,64257,64258,8225,183,8218,8222,8240,194,202,193,203,200,205,206,207,204,211,212,63743,210,218,219,217,305,710,732,175,728,729,730,184,733,731,711],
    "windows-874":[8364,129,130,131,132,8230,134,135,136,137,138,139,140,141,142,143,144,8216,8217,8220,8221,8226,8211,8212,152,153,154,155,156,157,158,159,160,3585,3586,3587,3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,3604,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,3630,3631,3632,3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,null,null,null,null,3647,3648,3649,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,null,null,null,null],
    "windows-1250":[8364,129,8218,131,8222,8230,8224,8225,136,8240,352,8249,346,356,381,377,144,8216,8217,8220,8221,8226,8211,8212,152,8482,353,8250,347,357,382,378,160,711,728,321,164,260,166,167,168,169,350,171,172,173,174,379,176,177,731,322,180,181,182,183,184,261,351,187,317,733,318,380,340,193,194,258,196,313,262,199,268,201,280,203,282,205,206,270,272,323,327,211,212,336,214,215,344,366,218,368,220,221,354,223,341,225,226,259,228,314,263,231,269,233,281,235,283,237,238,271,273,324,328,243,244,337,246,247,345,367,250,369,252,253,355,729],
    "windows-1251":[1026,1027,8218,1107,8222,8230,8224,8225,8364,8240,1033,8249,1034,1036,1035,1039,1106,8216,8217,8220,8221,8226,8211,8212,152,8482,1113,8250,1114,1116,1115,1119,160,1038,1118,1032,164,1168,166,167,1025,169,1028,171,172,173,174,1031,176,177,1030,1110,1169,181,182,183,1105,8470,1108,187,1112,1029,1109,1111,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103],
    "windows-1252":[8364,129,8218,402,8222,8230,8224,8225,710,8240,352,8249,338,141,381,143,144,8216,8217,8220,8221,8226,8211,8212,732,8482,353,8250,339,157,382,376,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255],
    "windows-1253":[8364,129,8218,402,8222,8230,8224,8225,136,8240,138,8249,140,141,142,143,144,8216,8217,8220,8221,8226,8211,8212,152,8482,154,8250,156,157,158,159,160,901,902,163,164,165,166,167,168,169,null,171,172,173,174,8213,176,177,178,179,900,181,182,183,904,905,906,187,908,189,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,null,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,null],
    "windows-1254":[8364,129,8218,402,8222,8230,8224,8225,710,8240,352,8249,338,141,142,143,144,8216,8217,8220,8221,8226,8211,8212,732,8482,353,8250,339,157,158,376,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,286,209,210,211,212,213,214,215,216,217,218,219,220,304,350,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,287,241,242,243,244,245,246,247,248,249,250,251,252,305,351,255],
    "windows-1255":[8364,129,8218,402,8222,8230,8224,8225,710,8240,138,8249,140,141,142,143,144,8216,8217,8220,8221,8226,8211,8212,732,8482,154,8250,156,157,158,159,160,161,162,163,8362,165,166,167,168,169,215,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,247,187,188,189,190,191,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,null,1467,1468,1469,1470,1471,1472,1473,1474,1475,1520,1521,1522,1523,1524,null,null,null,null,null,null,null,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,null,null,8206,8207,null],
    "windows-1256":[8364,1662,8218,402,8222,8230,8224,8225,710,8240,1657,8249,338,1670,1688,1672,1711,8216,8217,8220,8221,8226,8211,8212,1705,8482,1681,8250,339,8204,8205,1722,160,1548,162,163,164,165,166,167,168,169,1726,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,1563,187,188,189,190,1567,1729,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,215,1591,1592,1593,1594,1600,1601,1602,1603,224,1604,226,1605,1606,1607,1608,231,232,233,234,235,1609,1610,238,239,1611,1612,1613,1614,244,1615,1616,247,1617,249,1618,251,252,8206,8207,1746],
    "windows-1257":[8364,129,8218,131,8222,8230,8224,8225,136,8240,138,8249,140,168,711,184,144,8216,8217,8220,8221,8226,8211,8212,152,8482,154,8250,156,175,731,159,160,null,162,163,164,null,166,167,216,169,342,171,172,173,174,198,176,177,178,179,180,181,182,183,248,185,343,187,188,189,190,230,260,302,256,262,196,197,280,274,268,201,377,278,290,310,298,315,352,323,325,211,332,213,214,215,370,321,346,362,220,379,381,223,261,303,257,263,228,229,281,275,269,233,378,279,291,311,299,316,353,324,326,243,333,245,246,247,371,322,347,363,252,380,382,729],
    "windows-1258":[8364,129,8218,402,8222,8230,8224,8225,710,8240,138,8249,338,141,142,143,144,8216,8217,8220,8221,8226,8211,8212,732,8482,154,8250,339,157,158,376,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,258,196,197,198,199,200,201,202,203,768,205,206,207,272,209,777,211,212,416,214,215,216,217,218,219,220,431,771,223,224,225,226,259,228,229,230,231,232,233,234,235,769,237,238,239,273,241,803,243,244,417,246,247,248,249,250,251,252,432,8363,255],
    "x-mac-cyrillic":[1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,8224,176,1168,163,167,8226,182,1030,174,169,8482,1026,1106,8800,1027,1107,8734,177,8804,8805,1110,181,1169,1032,1028,1108,1031,1111,1033,1113,1034,1114,1112,1029,172,8730,402,8776,8710,171,187,8230,160,1035,1115,1036,1116,1109,8211,8212,8220,8221,8216,8217,247,8222,1038,1118,1039,1119,8470,1025,1105,1103,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,8364]
  };

  // Optional (due to size)
  // NOTE: prepend <script src="index-$ENCODINGNAME.js"></script> to enable
  indexes["gbk"] = global['gbkIndex'] || [];
  indexes["big5"] = global['big5Index'] || [];
  indexes["jis0208"] = global['jis0208Index'] || [];
  indexes["jis0212"] = global['jis0212Index'] || [];
  indexes["euc-kr"] = global['euckrIndex'] || [];


  //
  // 7. The encoding
  //

  // 7.1 utf-8

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function UTF8Decoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ utf8_code_point = 0,
        /** @type {number} */ utf8_bytes_needed = 0,
        /** @type {number} */ utf8_bytes_seen = 0,
        /** @type {number} */ utf8_lower_boundary = 0;
    this.decode = function (byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof) {
        if (utf8_bytes_needed !== 0) {
          return decoderError(fatal);
        }
        return eof;
      }
      byte_pointer.offset(1);

      if (utf8_bytes_needed === 0) {
        if (inRange(bite, 0x00, 0x7F)) {
          return bite;
        } else if (inRange(bite, 0xC0, 0xDF)) {
          utf8_bytes_needed = 1;
          utf8_lower_boundary = 0x80;
          utf8_code_point = bite - 0xC0;
        } else if (inRange(bite, 0xE0, 0xEF)) {
          utf8_bytes_needed = 2;
          utf8_lower_boundary = 0x800;
          utf8_code_point = bite - 0xE0;
        } else if (inRange(bite, 0xF0, 0xF7)) {
          utf8_bytes_needed = 3;
          utf8_lower_boundary = 0x10000;
          utf8_code_point = bite - 0xF0;
        } else if (inRange(bite, 0xF8, 0xFB)) {
          utf8_bytes_needed = 4;
          utf8_lower_boundary = 0x200000;
          utf8_code_point = bite - 0xF8;
        } else if (inRange(bite, 0xFC, 0xFD)) {
          utf8_bytes_needed = 5;
          utf8_lower_boundary = 0x4000000;
          utf8_code_point = bite - 0xFC;
        } else {
          return decoderError(fatal);
        }
        utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
        return null;
      }
      if (!inRange(bite, 0x80, 0xBF)) {
        utf8_code_point = 0;
        utf8_bytes_needed = 0;
        utf8_bytes_seen = 0;
        utf8_lower_boundary = 0;
        byte_pointer.offset(-1);
        return decoderError(fatal);
      }
      utf8_bytes_seen += 1;
      utf8_code_point = utf8_code_point + (bite - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
      if (utf8_bytes_seen !== utf8_bytes_needed) {
        return null;
      }
      var code_point = utf8_code_point;
      var lower_boundary = utf8_lower_boundary;
      utf8_code_point = 0;
      utf8_bytes_needed = 0;
      utf8_bytes_seen = 0;
      utf8_lower_boundary = 0;
      if (code_point >= lower_boundary &&
          code_point <= 0x10FFFF &&
          (!inRange(code_point, 0xD800, 0xDFFF))) {
        return code_point;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function UTF8Encoder(options) {
    var fatal = options.fatal;
    this.encode = function (output_byte_stream, input_code_point_stream) {
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (inRange(code_point, 0xD800, 0xDFFF)) {
        encoderError(code_point);
      }
      if (inRange(code_point, 0x0000, 0x007f)) {
        output_byte_stream.write(code_point);
        return;
      }
      var count, offset;
      if (inRange(code_point, 0x0080, 0x07FF)) {
          count = 1;
        offset = 0xC0;
      } else if (inRange(code_point, 0x0800, 0xFFFF)) {
        count = 2;
        offset = 0xE0;
      } else if (inRange(code_point, 0x10000, 0x10FFFF)) {
        count = 3;
        offset = 0xF0;
      }
      output_byte_stream.write(Math.floor(code_point / Math.pow(64, count)) + offset);
      while (count > 0) {
        var temp = Math.floor(code_point / Math.pow(64, count - 1));
        output_byte_stream.write(0x80 + (temp % 64));
        count -= 1;
      }
    };
  }

  //
  // 8. Legacy single-byte encodings
  //

  /**
   * @constructor
   * @param {Array.<number>} index
   * @param {{fatal: boolean}} options
   */
  function SingleByteDecoder(index, options) {
    var fatal = options.fatal;
    this.decode = function (byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof) {
        return eof;
      }
      byte_pointer.offset(1);
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      } else {
        var code_point = index[bite - 0x80];
        if (code_point === null) {
          return decoderError(fatal);
        } else {
          return code_point;
        }
      }
    };
  }

  /**
   * @constructor
   * @param {Array.<?number>} index
   * @param {{fatal: boolean}} options
   */
  function SingleByteEncoder(index, options) {
    var fatal = options.fatal;
    this.encode = function (output_byte_stream, input_code_point_stream) {
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        output_byte_stream.write(code_point);
      } else {
        var pointer = pointerFor(code_point, index);
        if (pointer === null) {
          encoderError(code_point);
        }
        output_byte_stream.write(pointer + 0x80);
      }
    };
  }

  (function() {
    ["ibm864", "ibm866", "iso-8859-2", "iso-8859-3", "iso-8859-4",
     "iso-8859-5", "iso-8859-6", "iso-8859-7", "iso-8859-8", "iso-8859-10",
     "iso-8859-13", "iso-8859-14", "iso-8859-15", "iso-8859-16", "koi8-r",
     "koi8-u", "macintosh", "windows-874", "windows-1250", "windows-1251",
     "windows-1252", "windows-1253", "windows-1254", "windows-1255",
     "windows-1256", "windows-1257", "windows-1258", "x-mac-cyrillic"
    ].forEach(
      function (name) {
        var encoding = name_to_encoding[name];
        var index = indexes[name];
        encoding.getDecoder = function (options) { return new SingleByteDecoder(index, options); };
        encoding.getEncoder = function (options) { return new SingleByteEncoder(index, options); };
      }
    );
  }());

  //
  // 9. Legacy multi-byte Chinese (simplified) encodings
  //

  /**
   * @param {number} pointer
   * @return {?number}
   */
  function gbkCodePoint(pointer) {
    return indexes["gbk"][pointer] || null;
  }

  function gb18030CodePoint(pointer) {
    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575)) {
      return null;
    }
    var offset = 0, code_point_offset = 0, index = indexes["gb18030"];
    for (var i = 0; i < index.length; ++i) {
      var entry = index[i];
      if (entry[0] <= pointer) {
        offset = entry[0];
        code_point_offset = entry[1];
      } else {
        break;
      }
    }
    return code_point_offset + pointer - offset;
  }

  // 9.1 gbk
  // 9.2 gb18030

  /**
   * @constructor
   * @param {boolean} gb18030
   * @param {{fatal: boolean}} options
   */
  function GBKDecoder(gb18030, options) {
    var fatal = options.fatal;
    var /** @type {number} */ gbk_first = 0x00,
        /** @type {number} */ gbk_second = 0x00,
        /** @type {number} */ gbk_third = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof && gbk_first === 0x00 && gbk_second === 0x00 && gbk_third === 0x00) {
        return eof;
      }
      if (bite === eof && (gbk_first !== 0x00 || gbk_second !== 0x00 || gbk_third !== 0x00)) {
        gbk_first = 0x00;
        gbk_second = 0x00;
        gbk_third = 0x00;
        decoderError(fatal);
      }
      byte_pointer.offset(1);
      var code_point;
      if (gbk_third !== 0x00) {
        code_point = null;
        if (inRange(bite, 0x30, 0x39)) {
          code_point = gb18030CodePoint(
            (((gbk_first - 0x81) * 10 + (gbk_second - 0x30)) * 126 +
             (gbk_third - 0x81)) * 10 + bite - 0x30);
        }
        gbk_first = 0x00;
        gbk_second = 0x00;
        gbk_third = 0x00;
        if (code_point === null) {
          byte_pointer.offset(-3);
          return decoderError(fatal);
        }
        return code_point;
      }
      if (gbk_second !== 0x00) {
        if (inRange(bite, 0x81, 0xFE)) {
          gbk_third = bite;
          return null;
        }
        byte_pointer.offset(-2);
        gbk_first = 0x00;
        gbk_second = 0x00;
        return decoderError(fatal);
      }
      if (gbk_first !== 0x00) {
        if (inRange(bite, 0x30, 0x39) && gb18030) {
          gbk_second = bite;
          return null;
        }
        var lead = gbk_first;
        var pointer = null;
        gbk_first = 0x00;
        var offset = bite < 0x7F ? 0x40 : 0x41;
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) {
          pointer = (lead - 0x81) * 190 + (bite - offset);
        }
        code_point = pointer === null ? null : gbkCodePoint(pointer);
        if (pointer === null) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      if (bite === 0x80) {
        return 0x20AC;
      }
      if (inRange(bite, 0x81, 0xFE)) {
        gbk_first = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {boolean} gb18030
   * @param {{fatal: boolean}} options
   */
  function GBKEncoder(gb18030, options) {
    var fatal = options.fatal;
    this.encode = function(output_byte_stream, input_code_point_stream) {
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        output_byte_stream.write(code_point);
        return;
      }
      var pointer = pointerFor(code_point, indexes["gbk"]);
      if (pointer !== null) {
        var lead = Math.floor(pointer / 190) + 0x81;
        var trail = pointer % 190;
        var offset = trail < 0x3F ? 0x40 : 0x41;
        output_byte_stream.write(lead, trail + offset);
        return;
      }
      if (pointer === null && !gb18030) {
        encoderError(code_point);
        return;
      }
      pointer = pointerFor(code_point, indexes["gb18030"]);
      var byte1 = Math.floor(pointer / 10 / 126 / 10);
      pointer = pointer - byte1 * 10 * 126 * 10;
      var byte2 = Math.floor(pointer / 10 / 126);
      pointer = pointer - byte2 * 10 * 126; // TODO: Typo in spec?
      var byte3 = Math.floor(pointer / 10);
      var byte4 = pointer - byte3 * 10;
      output_byte_stream.write(byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30);
    };
  }

  // 9.3 hz-gb-2312

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function HZGB2312Decoder(options) {
    var fatal = options.fatal;
    var /** @type {boolean} */ hzgb2312 = false,
        /** @type {number} */ hzgb2312_lead = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof && hzgb2312_lead === 0x00) {
        return eof;
      }
      if (bite === eof && hzgb2312_lead !== 0x00) {
        hzgb2312_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (hzgb2312_lead === 0x7E) {
        hzgb2312_lead = 0x00;
        if (bite === 0x7B) {
          hzgb2312 = true;
          return null;
        }
        if (bite === 0x7D) {
          hzgb2312 = false;
          return null;
        }
        if (bite === 0x7E) {
          return 0x007E;
        }
        if (bite === 0x0A) {
          hzgb2312_lead = 0x00;
          return null;
        }
        byte_pointer.offset(-1);
        return decoderError(fatal);
      }
      if (hzgb2312_lead !== 0x00) {
        var lead = hzgb2312_lead;
        hzgb2312_lead = 0x00;
        var code_point = null;
        if (inRange(bite, 0x21, 0x7E)) {
          code_point = gbkCodePoint((lead - 1) * 190 + (bite + 0x3F));
        }
        if (bite === 0x0A) {
          hzgb2312 = false;
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (bite === 0x7E) {
        hzgb2312_lead = 0x7E;
        return null;
      }
      if (hzgb2312) {
        if (inRange(bite, 0x20, 0x7F)) {
          hzgb2312_lead = bite;
          return null;
        }
        if (bite === 0x0A) {
          hzgb2312 = false;
        }
        return decoderError(fatal);
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function HZGB2312Encoder(options) {
    var fatal = options.fatal;
    var hzgb2312 = false;
    this.encode = function(output_byte_stream, input_code_point_stream) {
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (inRange(code_point, 0x0000, 0x007F) && hzgb2312) {
        input_code_point_stream.offset(-1);
        hzgb2312 = false;
        output_byte_stream.write(0x7E, 0x7D);
        return;
      }
      if (code_point === 0x007E) {
        output_byte_stream.write(0x7E, 0x7E);
        return;
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        output_byte_stream.write(code_point);
        return;
      }
      if (!hzgb2312) {
        input_code_point_stream.offset(-1);
        hzgb2312 = true;
        output_byte_stream.write(0x7E, 0x7B);
        return;
      }
      var pointer = pointerFor(code_point, indexes["gbk"]);
      if (pointer === null) {
        encoderError(code_point);
        return;
      }
      var lead = Math.floor(pointer / 190) + 1;
      var trail = pointer % 190 - 0x3F;
      if (!inRange(lead, 0x21, 0x7E) || !inRange(trail, 0x21, 0x7E)) {
        encoderError(code_point);
        return;
      }
      output_byte_stream.write(lead, trail);
    };
  }


  //
  // 10. Legacy multi-byte Chinese (traditional) encodings
  //

  // 10.1 big5

  /**
   * @param {number} pointer
   * @return {?number}
   */
  function big5CodePoint(pointer) {
    return indexes["big5"][pointer] || null;
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function Big5Decoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ big5_lead = 0x00,
        /** @type {?number} */ big5_pending = null;

    this.decode = function(byte_pointer) {
      if (big5_pending !== null) {
        var pending = big5_pending;
        big5_pending = null;
        return pending;
      }
      var bite = byte_pointer.get();
      if (bite === eof && big5_lead === 0x00) {
        return eof;
      }
      if (bite === eof && big5_lead !== 0x00) {
        big5_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (big5_lead !== 0x00) {
        var lead = big5_lead;
        var pointer = null;
        big5_lead = 0x00;
        if (lead === 0x88 && bite === 0x62) {
          big5_pending = 0x0304;
          return 0x00CA;
        }
        if (lead === 0x88 && bite === 0x64) {
          big5_pending = 0x030C;
          return 0x00CA;
        }
        if (lead === 0x88 && bite === 0xA3) {
          big5_pending = 0x0304;
          return 0x00EA;
        }
        if (lead === 0x88 && bite === 0xA5) {
          big5_pending = 0x030C;
          return 0x00EA;
        }
        var offset = (bite < 0x7F) ? 0x40 : 0x62;
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) {
          pointer = (lead - 0x81) * 157 + (bite - offset);
        }
        var code_point = (pointer === null) ? null : big5CodePoint(pointer);
        if (pointer === null) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      if (inRange(bite, 0x81, 0xFE)) {
        big5_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }


  //
  // 11. Legacy multi-byte Japanese encodings
  //

  /**
   * @param {number} pointer
   * @return {?number}
   */
  function jis0208CodePoint(pointer) {
    return indexes["jis0208"][pointer] || null;
  }

  /**
   * @param {number} pointer
   * @return {?number}
   */
  function jis0212CodePoint(pointer) {
    return indexes["jis0212"][pointer] || null;
  }

  // 11.1 euc.jp

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function EUCJPDecoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ eucjp_first = 0x00,
        /** @type {number} */ eucjp_second = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof) {
        if (eucjp_first === 0x00 && eucjp_second === 0x00) {
          return eof;
        } else {
          eucjp_first = 0x00;
          eucjp_second = 0x00;
          return decoderError(fatal);
        }
      }
      byte_pointer.offset(1);

      var lead, code_point;
      if (eucjp_second !== 0x00) {
        lead = eucjp_second;
        eucjp_second = 0x00;
        code_point = null;
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = jis0212CodePoint((lead - 0xA1) * 94 + bite - 0xA1);
        }
        if (!inRange(bite, 0xA1, 0xFE)) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (eucjp_first === 0x8E && inRange(bite, 0xA1, 0xDF)) {
        eucjp_first = 0x00;
        return 0xFF61 + bite - 0xA1;
      }
      if (eucjp_first === 0x8F && inRange(bite, 0xA1, 0xFE)) {
        eucjp_first = 0x00;
        eucjp_second = bite;
        return null;
      }
      if (eucjp_first !== 0x00) {
        lead = eucjp_first;
        eucjp_first = 0x00;
        code_point = null;
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = jis0208CodePoint((lead - 0xA1) * 94 + bite - 0xA1);
        }
        if (!inRange(bite, 0xA1, 0xFE)) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      if (bite === 0x8E || bite === 0x8F || (inRange(bite, 0xA1, 0xFE))) {
        eucjp_first = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  // 11.2 iso-2022-jp

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      escape_start: 1,
      escape_middle: 2,
      escape_final: 3,
      lead: 4,
      trail: 5,
      Katakana: 6
    };
    var /** @type {number} */ iso2022jp_state = state.ASCII,
        /** @type {boolean} */ iso2022jp_jis0212 = false,
        /** @type {number} */ iso2022jp_lead = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite !== eof) {
        byte_pointer.offset(1);
      }
      switch (iso2022jp_state) {
      default:
      case state.ASCII:
        if (bite === 0x1B) {
          iso2022jp_state = state.escape_start;
          return null;
        }
        if (inRange(bite, 0x00, 0x7F)) {
          return bite;
        }
        if (bite === eof) {
          return eof;
        }
        return decoderError(fatal);

      case state.escape_start:
        if (bite === 0x24 || bite === 0x28) {
          iso2022jp_lead = bite;
          iso2022jp_state = state.escape_middle;
          return null;
        }
        if (bite != eof) {
          byte_pointer.offset(-1);
        }
        iso2022jp_state = state.ASCII;
        return decoderError(fatal);

      case state.escape_middle:
        var lead = iso2022jp_lead;
        iso2022jp_lead = 0x00;
        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) {
          iso2022jp_jis0212 = false;
          iso2022jp_state = state.lead;
          return null;
        }
        if (lead === 0x24 && bite === 0x28) {
          iso2022jp_state = state.escape_final;
          return null;
        }
        if (lead === 0x28 && (bite === 0x42 || bite === 0x4A)) {
          iso2022jp_state = state.ASCII;
          return null;
        }
        if (lead === 0x28 && bite === 0x49) {
          iso2022jp_state = state.Katakana;
          return null;
        }
        if (bite === eof) {
          byte_pointer.offset(-1);
        } else {
          byte_pointer.offset(-2);
        }
        iso2022jp_state = state.ASCII;
        return decoderError(fatal);

      case state.escape_final:
        if (bite === 0x44) {
          iso2022jp_jis0212 = true;
          iso2022jp_state = state.lead;
          return null;
        }
        if (bite === eof) {
          byte_pointer.offset(-2);
        } else {
          byte_pointer.offset(-3);
        }
        iso2022jp_state = state.ASCII;
        return decoderError(fatal);

      case state.lead:
        if (bite === 0x0A) {
          iso2022jp_state = state.ASCII;
          return decoderError(fatal, 0x000A);
        }
        if (bite === 0x1B) {
          iso2022jp_state = state.escape_start;
          return null;
        }
        if (bite === eof) {
          return eof;
        }
        iso2022jp_lead = bite;
        iso2022jp_state = state.trail;
        return null;

      case state.trail:
        iso2022jp_state = state.lead;
        if (bite === eof) {
          return decoderError(fatal);
        }
        var code_point = null;
        var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;
        if (inRange(iso2022jp_lead, 0x21, 0x7E) && inRange(bite, 0x21, 0x7E)) {
          code_point = (iso2022jp_jis0212 === false) ? jis0208CodePoint(pointer) : jis0212CodePoint(pointer);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;

      case state.Katakana:
        if (bite === 0x1B) {
          iso2022jp_state = state.escape_start;
          return null;
        }
        if (inRange(bite, 0x21, 0x5F)) {
          return 0xFF61 + bite - 0x21;
        }
        if (bite === eof) {
          return eof;
        }
        return decoderError(fatal);
      }
    };
  }

  // 11.3 shift_jis

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ShiftJISDecoder(options) {
    var fatal = options.fatal;
    /** @const */ var shiftjis_fallback_code_point = 0x30FB;
    var /** @type {number} */ shiftjis_lead = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof && shiftjis_lead === 0x00) {
        return eof;
      }
      if (bite === eof && shiftjis_lead !== 0x00) {
        shiftjis_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (shiftjis_lead !== 0x00) {
        var lead = shiftjis_lead;
        shiftjis_lead = 0x00;
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) {
          var offset = (bite < 0x7F) ? 0x40 : 0x41;
          var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;
          var code_point = jis0208CodePoint((lead - lead_offset) * 188 + bite - offset);
          if (code_point === null) {
            return decoderError(fatal, shiftjis_fallback_code_point);
          }
          return code_point;
        }
        byte_pointer.offset(-1);
        return decoderError(fatal);
      }
      if (inRange(bite, 0x00, 0x80)) {
        return bite;
      }
      if (inRange(bite, 0xA1, 0xDF)) {
        return 0xFF61 + bite - 0xA1;
      }
      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {
        shiftjis_lead  = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  //
  // 12. Legacy multi-byte Korean encodings
  //

  /**
   * @param {number} pointer
   * @return {?number}
   */
  function euckrCodePoint(pointer) {
    return indexes["euc-kr"][pointer] || null;
  }

  // 12.1 euc-kr

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function EUCKRDecoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ euckr_lead = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof && euckr_lead === 0) {
        return eof;
      }
      if (bite === eof && euckr_lead !== 0) {
        euckr_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (euckr_lead !== 0x00) {
        var lead = euckr_lead;
        var pointer = null;
        euckr_lead = 0x00;

        if (inRange(lead, 0x81, 0xC6)) {
          var temp = (26 + 26 + 126) * (lead - 0x81);
          if (inRange(bite, 0x41, 0x5A)) {
            pointer = temp + bite - 0x41;
          } else if (inRange(bite, 0x61, 0x7A)) {
            pointer = temp + 26 + bite - 0x61;
          } else if (inRange(bite, 0x81, 0xFE)) {
            pointer = temp + 26 + 26 + bite - 0x81;
          }
        }

        if (inRange(lead, 0xC7, 0xFD) && inRange(bite, 0xA1, 0xFE)) {
          pointer = (26 + 26 + 126) * (0xC7 - 0x81) + (lead - 0xC7) * 94 + (bite - 0xA1);
        }

        var code_point = (pointer === null) ? null : euckrCodePoint(pointer);
        if (pointer === null) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }

      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }

      if (inRange(bite, 0x81, 0xFD)) {
        euckr_lead = bite;
        return null;
      }

      return decoderError(fatal);
    };
  }

  // 12.2 iso-2022-kr

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022KRDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      escape_start: 1,
      escape_middle: 2,
      escape_end: 3,
      lead: 4,
      trail: 5
    };
    var /** @type {number} */ iso2022kr_state = state.ASCII,
        /** @type {number} */ iso2022kr_lead = 0x00;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite !== eof) {
        byte_pointer.offset(1);
      }
      switch (iso2022kr_state) {
      default:
      case state.ASCII:
        if (bite === 0x0E) {
          iso2022kr_state = state.lead;
          return null;
        } else if (bite === 0x0F) {
          return null;
        } else if (bite === 0x1B) {
          iso2022kr_state = state.escape_start;
          return null;
        } else if (inRange(bite, 0x00, 0x7F)) {
          return bite;
        } else if (bite === eof) {
          return eof;
        } else {
          return decoderError(fatal);
        }
      case state.escape_start:
        if (bite === 0x24) {
          iso2022kr_state = state.escape_middle;
          return null;
        }
        if (bite !== eof) {
          byte_pointer.offset(-1);
        }
        iso2022kr_state = state.ASCII;
        return decoderError(fatal);
      case state.escape_middle:
        if (bite === 0x29) {
          iso2022kr_state = state.escape_end;
          return null;
        }
        if (bite === eof) {
          byte_pointer.offset(-1);
        } else {
          byte_pointer.offset(-2);
        }
        iso2022kr_state = state.ASCII;
        return decoderError(fatal);
      case state.escape_end:
        if (bite === 0x43) {
          iso2022kr_state = state.ASCII;
          return null;
        }
        if (bite === eof) {
          byte_pointer.offset(-2);
        } else {
          byte_pointer.offset(-3);
        }
        iso2022kr_state = state.ASCII;
        return decoderError(fatal);
      case state.lead:
        if (bite === 0x0A) {
          iso2022kr_state = state.ASCII;
          return decoderError(fatal, 0x000A);
        } else if (bite === 0x0E) {
          return null;
        } else if (bite === 0x0F) {
          iso2022kr_state = state.ASCII;
          return null;
        } else if (bite === eof) {
          return eof;
        } else {
          iso2022kr_lead = bite;
          iso2022kr_state = state.trail;
          return null;
        }
      case state.trail:
        iso2022kr_state = state.lead;
        if (bite === eof) {
          return decoderError(fatal);
        }
        var code_point = null;
        if (inRange(iso2022kr_lead, 0x21, 0x46) && inRange(bite, 0x21, 0x7E)) {
          code_point = euckrCodePoint((26 + 26 + 126) * (iso2022kr_lead - 1) + 26 + 26 + bite - 1);
        } else if (inRange(iso2022kr_lead, 0x47, 0x7E) && inRange(bite, 0x21, 0x7E)) {
          code_point = euckrCodePoint((26 + 26 + 126) * (0xC7 - 0x81) + (iso2022kr_lead - 0x47) * 94 + (bite - 0x21));
        }
        if (code_point !== null) {
          return code_point;
        }
        return decoderError(fatal);
      }
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022KREncoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      lead: 1
    };
    var /** @type {boolean} */ iso2022kr_initialization = false,
        /** @type {number} */ iso2022kr_state = state.ASCII;
    this.encode = function(output_byte_stream, input_code_point_stream) {
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (!iso2022kr_initialization) {
        iso2022kr_initialization = true;
        output_byte_stream.write(0x1B, 0x24, 0x29, 0x43);
      }
      if (inRange(code_point, 0x0000, 0x007F) && iso2022kr_state !== state.ASCII) {
        input_code_point_stream.offset(-1);
        iso2022kr_state = state.ASCII;
        output_byte_stream.write(0x0F);
        return;
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        output_byte_stream.write(code_point);
        return;
      }
      if (iso2022kr_state !== state.lead) {
        input_code_point_stream.offset(-1);
        iso2022kr_state = state.lead;
        output_byte_stream.write(0x0E);
        return;
      }
      var pointer = pointerFor(code_point, indexes["euc-kr"]);
      if (pointer === null) {
        encoderError(code_point);
        return;
      }
      var lead, trail;
      if (pointer < (26 + 26 + 126) * (0xC7 - 0x81)) {
        lead = Math.floor(pointer / (26 + 26 + 126)) + 1;
        trail = pointer % (26 + 26 + 126) - 26 - 26 + 1;
        if (!inRange(lead, 0x21, 0x46) || !inRange(trail, 0x21, 0x7E)) {
          encoderError(code_point);
          return;
        }
        output_byte_stream.write(lead, trail);
        return;
      }
      pointer = pointer - (26 + 26 + 126) * (0xC7 - 0x81);
      lead = Math.floor(pointer / 94) + 0x47;
      trail = pointer % 94 + 0x21;
      if (!inRange(lead, 0x47, 0x7E) || !inRange(trail, 0x21, 0x7E)) {
        encoderError(code_point);
        return;
      }
      output_byte_stream.write(lead, trail);
      return;
    };
  }


  //
  // 13. Legacy utf-16 encodings
  //

  // 13.1 utf-16
  // 13.2 utf-16be

  /**
   * @constructor
   * @param {boolean} utf16_be
   * @param {{fatal: boolean}} options
   */
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.fatal;
    var /** @type {?number} */ utf16_lead_byte = null,
        /** @type {?number} */ utf16_lead_surrogate = null;
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof && utf16_lead_byte === null && utf16_lead_surrogate === null) {
        return eof;
      }
      if (bite === eof && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null;
      }
      var code_point;
      if (utf16_be) {
        code_point = (utf16_lead_byte << 8) + bite;
      } else {
        code_point = (bite << 8) + utf16_lead_byte;
      }
      utf16_lead_byte = null;
      if (utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;
        if (inRange(code_point, 0xDC00, 0xDFFF)) {
          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 + (code_point - 0xDC00);
        } else {
          byte_pointer.offset(-2);
          return decoderError(fatal);
        }
      }
      if (inRange(code_point, 0xD800, 0xDBFF)) {
        utf16_lead_surrogate = code_point;
        return null;
      }
      if (inRange(code_point, 0xDC00, 0xDFFF)) {
        return decoderError(fatal);
      }
      return code_point;
    };
  }

  /**
   * @constructor
   * @param {boolean} utf16_be
   * @param {{fatal: boolean}} options
   */
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.fatal;
    this.encode = function(output_byte_stream, input_code_point_stream) {
      function convert_to_bytes(code_unit) {
        var byte1 = code_unit >> 8;
        var byte2 = code_unit & 0xFF;
        if (utf16_be) {
          output_byte_stream.write(byte1, byte2);
        } else {
          output_byte_stream.write(byte2, byte1);
        }
      }
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (inRange(code_point, 0xD800, 0xDFFF)) {
        encoderError(code_point);
      }
      if (code_point <= 0xFFFF) {
        convert_to_bytes(code_point);
      } else {
        var lead = ((code_point - 0x10000) / 0x400) + 0xD800;
        var trail = ((code_point - 0x10000) % 0x400) + 0xDC00;
        convert_to_bytes(lead);
        convert_to_bytes(trail);
      }
    };
  }

  // NOTE: currently unused
  function detectEncoding(label, input_stream) {
    if (input_stream.match([0xFF, 0xFE])) {
      input_stream.offset(2);
      return 'utf-16';
    } else if (input_stream.match([0xFE, 0xFF])) {
      input_stream.offset(2);
      return 'utf-16be';
    } else if (input_stream.match([0xEF, 0xBB, 0xBF])) {
      input_stream.offset(3);
      return 'utf-8';
    }
    return label;
  }

  //
  // Implementation of Text Encoding Web API
  //

  codecs.push({
    name: 'binary',
    labels: ['binary'],
    getEncoder: function (options) { return new BinaryEncoder(options); },
    getDecoder: function (options) { return new BinaryDecoder(options); }
  });

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function BinaryEncoder(options) {
    var fatal = options.fatal;
    this.encode = function (output_byte_stream, input_code_point_stream) {
      var code_point = input_code_point_stream.read();
      if (code_point === eof) {
        return;
      }
      if (code_point > 0xff) {
        encoderError(code_point);
      }
      output_byte_stream.write(code_point);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function BinaryDecoder(options) {
    var fatal = options.fatal;
    this.decode = function (byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === eof) {
        return eof;
      }
      byte_pointer.offset(1);
      return bite;
    };
  }


  /** @const */ var DEFAULT_ENCODING = 'utf-8';

  /**
   * @constructor
   * @param {string=} encoding
   * @param {{fatal: boolean}=} options
   */
  function TextEncoder(encoding, options) {
    if (!this || this === global) {
      return new TextEncoder(encoding, options);
    }
    encoding = encoding ? String(encoding) : DEFAULT_ENCODING;
    options = Object(options);
    this._encoding = getEncoding(encoding); // may throw
    this._streaming = false;
    this._encoder = null;
    this._options = { fatal: Boolean(options.fatal) };
    return this;
  }

  TextEncoder.prototype = {
    /**
     * @param {string=} string
     * @param {{stream: boolean}=} options
     */
    encode: function encode(string, options) {
      string = string ? String(string) : "";
      options = Object(options);

      if (!this._streaming) {
        this._encoder = this._encoding.getEncoder(this._options);
      }
      this._streaming = Boolean(options.stream);

      var bytes = [];
      var output_stream = ByteOutputStream(bytes);
      var input_stream = CodePointInputStream(string);
      while (!input_stream.eof()) {
        this._encoder.encode(output_stream, input_stream, {
          // TODO: options?
        });
      }
      if (!this._streaming) {
        this._encoder.encode(output_stream, input_stream, {
          // TODO: options?
        });
        this._encoder = null;
      }
      return new Uint8Array(bytes);
    }
  };
  Object.defineProperty(TextEncoder.prototype, 'encoding',
    { get: function () { return this._encoding.name; } });


  /**
   * @constructor
   * @param {string=} encoding
   * @param {{fatal: boolean}=} options
   */
  function TextDecoder(encoding, options) {
    if (!this || this === global) {
      return new TextDecoder(encoding, options);
    }
    encoding = encoding ? String(encoding) : DEFAULT_ENCODING;
    options = Object(options);
    this._encoding = getEncoding(encoding); // may throw
    this._streaming = false;
    this._decoder = null;
    this._options = { fatal: Boolean(options.fatal) };
    return this;
  }

  // TODO: Issue if input byte stream is offset by decoder
  // TODO: BOM detection will not work if stream header spans multiple calls
  // (last N bytes of previous stream may need to be retained?)
  TextDecoder.prototype = {
    /**
     * @param {ArrayBufferView=} view
     * @param {{stream: boolean}=} options
     */
    decode: function decode(view, options) {
      if (view && !('buffer' in view && 'byteOffset' in view && 'byteLength' in view)) {
        throw new TypeError('Expected ArrayBufferView');
      } else if (!view) {
        view = new Uint8Array(0);
      }
      options = Object(options);

      if (!this._streaming) {
        this._decoder = this._encoding.getDecoder(this._options);
      }
      this._streaming = Boolean(options.stream);

      // TODO: encoding detection via BOM?

      var bytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
      var input_stream = ByteInputStream(bytes);

      var detected = detectEncoding(this._encoding.name, input_stream);
      if (getEncoding(detected) !== this._encoding) {
        throw new Error("BOM mismatch"); // TODO: what to do here?
      }

      var output_stream = CodePointOutputStream(), code_point;
      while (input_stream.get() !== eof) {
        code_point = this._decoder.decode(input_stream);
        if (code_point !== null && code_point !== eof) {
          output_stream.emit(code_point);
        }
      }
      if (!this._streaming) {
        do {
          code_point = this._decoder.decode(input_stream);
          if (code_point !== null && code_point !== eof) {
            output_stream.emit(code_point);
          }
        } while (code_point !== eof);
        this._decoder = null;
      }
      return output_stream.string();
    }
  };
  Object.defineProperty(TextDecoder.prototype, 'encoding',
    { get: function () { return this._encoding.name; } });

  global['TextEncoder'] = global['TextEncoder'] || TextEncoder;
  global['TextDecoder'] = global['TextDecoder'] || TextDecoder;
}(this));
